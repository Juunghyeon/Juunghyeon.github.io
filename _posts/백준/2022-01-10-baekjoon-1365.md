---
layout: single
title: "꼬인 전깃줄"
excerpt: "<골드2> 1365번: 꼬인 전깃줄"
categories:
  - Baekjoon
tag:
  - Cpp
  - LIS
  - Binary Search

toc: true
---

## 문제 설명
### 문제
공화국에 있는 유스타운 시에서는 길을 사이에 두고 전봇대가 아래와 같이 두 줄로 늘어서 있다. 그리고 길 왼편과 길 오른편의 전봇대는 하나의 전선으로 연결되어 있다. 어떤 전봇대도 두 개 이상의 다른 전봇대와 연결되어 있지는 않다.  
<div style="text-align : center;">
	<img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201004/picpicpicpicpicpicpicp.JPG">
</div>   
   
문제는 이 두 전봇대 사이에 있는 전깃줄이 매우 꼬여 있다는 점이다. 꼬여있는 전깃줄은 화재를 유발할 가능성이 있기 때문에 유스타운 시의 시장 임한수는 전격적으로 이 문제를 해결하기로 했다.   
   
임한수는 꼬여 있는 전깃줄 중 몇 개를 적절히 잘라 내어 이 문제를 해결하기로 했다. 하지만 이미 설치해 놓은 전선이 아깝기 때문에 잘라내는 전선을 최소로 하여 꼬여 있는 전선이 하나도 없게 만들려고 한다.    
   
유스타운 시의 시장 임한수를 도와 잘라내야 할 전선의 최소 개수를 구하는 프로그램을 작성하시오.

### 입력
첫 줄에 전봇대의 개수 N(1 ≤ N ≤ 100,000)이 주어지고, 이어서 N보다 작거나 같은 자연수가 N개 주어진다. i번째 줄에 입력되는 자연수는 길 왼쪽에 i번째 전봇대와 연결된 길 오른편의 전봇대가 몇 번 전봇대인지를 나타낸다.

### 출력
전선이 꼬이지 않으려면 최소 몇 개의 전선을 잘라내야 하는 지를 첫째 줄에 출력한다.

## 처음 접근법
각각의 전봇대쌍에 대해 겹치지 않는 전선의 개수를 나열하여 문제를 해결하는 방법을 생각했다. N은 최대 $$10^5$$ 인데 각각의 전봇대쌍을 돌게되면 $$10^10$$ 이 되므로 시간초과 문제가 생긴다.   
결국 문제를 해결하지 못하였다.

## 부족한 부분
 N은 최대 $$10^5$$ 인데 각각의 전봇대쌍을 돌게되면 $$10^10$$ 이 되므로 시간초과 문제가 생긴다.   


 f(x)=\sum_{n=0}^\infty\frac{f^{(n)}(a)}{n!}(x-a)^n   
결국 문제를 해결하지 못하였다.   
풀이는 마포 코딩박 님의 블로그를 참고했다.   
[](https://mapocodingpark.blogspot.com/2020/06/1365.html)

## 풀이


## 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(void)
{
	int N;
	int val;
	vector<int> vt;
	vector<int>::iterator iter;

	cin >> N;

	for (int i = 0; i < N; i++)
	{
		cin >> val;
		iter = lower_bound(vt.begin(), vt.end(), val);
		if (iter == vt.end())
			vt.push_back(val);
		else
			*iter = val;
	}
	cout << N - vt.size() << '\n';

	return (0);	
}
```